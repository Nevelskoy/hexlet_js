
/*************************************************************
	Практическое занятие №2 курс С110. Функции.
	"Старые" потоковые функции стандартной библиотеки
	Указатели на функции

*************************************************************/
#include <iostream>
#include <tchar.h>
//#include <cstdio>
//#include <cstdarg>
#include "other.h"


				
int _tmain()
{

#if 0
	//Задание 1. 
	//массивы в качестве аргументов функции.
	//Напишите два варианта функции печати элементов
	//1. встроенного двумерного массива
	//int ar[N][M]; //подумайте - как и где должны быть заданы N и M

	int ar[N][M];

	for (int i = 0; i < N; i++) {
		for (int y = 0; y < M; y++) {
			ar[i][y] = i + 1;
		}
	}

	//Вызов функции PrintArray   может выглядеть так:
//	PrintArray(ar, ... может быть, понадобится передать еще какие-нибудь данные);  //Важно! первый параметр- имя двумерного (!) массива
	std::cout << "The regular array:" << std::endl;
	PrintArray(ar, N, M);

	std::cout << std::endl;
	//2. динамического двумерного массива (обе размерности вычисляются)
	//Замечание:
	// Задать значения элементам массива можно с помощью кода

	int* pArr = new int[N * M];
	srand(time(0));
	for (size_t i = 0; i < N * M; i++) {
		*(pArr + i) = rand() % 10;
	}

	std::cout << "The dynamic array:" << std::endl;
	PrintArray(pArr, N, M);

#endif
/////////////////////////////////////////////////////////////////////////////
	//Задание 2.
#if 0
	//Передача имени встроенного двумерного массива в качестве параметра функции.
			//Напишите две взаимодополняющие друг друга функции:
			//1.  ... DayOfYear(...)
			//- преобразует день месяца (число,месяц и год задаются в качестве параметров)
			//в порядковый день года(возвращаемое значение)
			//2. ... DayOfMonth(...) - функция преобразует порядковый день года в день месяца
			// (принимает год и порядковый день года в качестве параметров и должна сформировать
			// день месяца и номер месяца и каким-то образом сообщить эти значения вызывающей процедуре)
			
			//В процессе вычислений Вам придется учитывать "високосный - невисокосный" год.
			//для проверки "високосности" года имеет смысл создать функцию (isLeepYear)
			//Для этого предлагается в каждую функцию в качестве одного из параметров передавать
			//данные приведенного ниже двухмерного массива nDayTab
	int nDayTab[2][12] = {
		{31,28,31,30,31,30,31,31,30,31,30,31}, //невисокосный год
		{31,29,31,30,31,30,31,31,30,31,30,31} };	//високосный год

	size_t day = 22, month = 7, year = 1986;
	//size_t numDay = DayOfYear(day, month, year, nDayTab);  //Важно! последний параметр- имя двумерного (!) массива
	size_t numDay = DayOfYear(day, month, year, nDayTab);
	std::cout << "DayOfYear: " << numDay << std::endl;

	


	//Проверка результата обратной функцией DayOfMonth        //Важно! последний параметр- имя двумерного (!) массива
	//...
#endif
	
/////////////////////////////////////////////////////////////////////////////
	//Задание 3.
	//Задание 3а. Функции с переменным числом параметров.
	//Напишите функцию (дана заготовка VarArgs, не использующая
	// макросы), которая принимает переменное число аргументов
	// типа int и выводит на печать число принятых параметров и
	// их значения.
	// Признаком конца списка является нулевое значение.
#if 0	
	int nN1=5, nN2=11, nN3=4, nN4=7, nN5=-1;
	VarArgs(nN1,0);	
	VarArgs(nN1,nN2,0);	
	VarArgs(nN1,nN2,nN3,nN4,nN5,0);	
	stop
	std::cout << std::endl;

	//Задание 3б. Модифицируйте функцию 3а с помощью макросов
	// va_start, va_arg, va_end
	std::cout << "Using the following macros: " << std::endl;
	VarArgsMacro(nN1, 0);
	VarArgsMacro(nN1, nN2, 0);
	VarArgsMacro(nN1, nN2, nN3, nN4, nN5, 0);
	stop

#endif
///////////////////////////////////////////////////////////////////
//Тема "Старые" потоковые функции стандартной библиотеки
//Задание 4.1 С помощью функции scanf сформирйуте три коэффициента: A,B,C
//Задание 4.2. Выведите таблицу значений y=A*x*x + B*x + C
//при изменении x в диапазоне -2 до +2 с шагом 0.5
#if 0
float A, B, C;
	printf("Enter A, B, C: ");
	scanf_s("%f %f %f", &A, &B, &C);
	printf("Table of values:\n");
	float x = -2;
	while (x <= 2) {
		float y = A * x * x + B * x + C;
		printf("%.1f | %.1f\n", x, y);
		x += 0.5;
	}
#endif
///////////////////////////////////////////////////////////////////
	//Тема Указатели на функции

	//Задание 5. Указатель на функцию. "Калькулятор".
	//Напишите функции:
	//1)Sum - принимает два значения double и возвращает сумму
	//этих значений
	//2)Sub- принимает два значения double и возвращает разность
	//этих значений
	//3)Mul - *
	//4)Div - /
	//5)а для возведения в степень можете использовать функцию стандартной библиотеки
	//		- pow(). Подсказка 1: прототип функции находится в <cmath>.
	//		Подсказка 2: стандартная библиотека предоставляет несколько перегруженных
	//		вариантов этой функции, а Вам потребуется сформировать указатель на 
	//		double pow(double, double);

	//Предоставьте пользователю	следующую возможность:
	//пока пользователь хочет пользоваться услугами Вашего калькулятора,
	//он может вводить два значения и знак операции
	//а Вы выводите результат. Результат получаете посредством вызова
	//соответствующей Вашей функции по указателю.
	//Предусмотрите возможность ввода непредусмотренного знака операции


	
		///////////////////////////////////////////////////////////////////
#if 1
	//Задание 6. Указатель на функцию в качестве аргумента.
	//Дана заготовка функции сортировки любых объектов - Sort.
	//Функция принимает следующие параметры:
	//1) указатель на первый сортируемый элемент
	//2) количество сортируемых элементов
	//3) размер элемента в байтах
	//4) указатель на функцию перестановки элементов
	//5) указатель на функцию сравнения элементов

	//6a. Напишите функцию перестановки двух целых значений -
	// SwapInt, которая принимает два void указателя и 
	//меняет значения местами

	//Напишите функцию сравнения двух целых значений -
	// CmpInt, которая принимает два void указателя и
	//возвращает int результат сравнения: 
	//<0 - первый элемент меньше, чем второй
	//=0 - равны
	//>0 - первый элемент больше, чем второй
		int nTotal = 5;
		int nAr[] = { 4, 12, 45, 5, 67 };	//массив для сортировки

		//Печать исходного массива
		PrAr(nAr, nTotal);
		//Вызов сортировки

		Sort(reinterpret_cast<char*>(&nAr[0]), nTotal, sizeof(int), SwapInt, CmpInt);
		
		//Печать результатов сортировки

		PrAr(nAr, nTotal);

		std::cout << std::endl;
		std::cout << "Compare Double: " << std::endl;
		std::cout << std::endl;
	//Задание 6б. По аналогии с 6а создайте вспомогательные
	//функции - SwapDouble и CmpDouble и вызовите функцию Sort
	//для сортировки массива вещественных значений.
		double DnAr[] = { 8.0, 33.23, 15.2, 55.0, 6.23 };
		int DnTotal = 5;

		PrAr(DnAr, DnTotal);

		Sort(reinterpret_cast<char*>(&DnAr[0]), nTotal, sizeof(double), SwapDouble, CmpDouble);

		PrAr(DnAr, DnTotal);
	
	//Задание 6в*. По аналогии с 6а создайте вспомогательные
	//функции - SwapStr и CmpStr и вызовите функцию Sort
	//для сортировки массива указателей на строки.
		char strTmp[] = "Hello";
		const char* arStr[] = { strTmp, "QQQ", "SDF", "ABC", "Abba", "ENFR", "En"};

		int size_arStr = 7;
		std::cout << std::endl;
	//Замечание:
	
	//в массиве линейно лежат АДРЕСА строк, надо передать АДРЕС массива, 
		Sort(reinterpret_cast<char*>(&arStr[0]), size_arStr, sizeof(arStr[0]), SwapChar, CmpChar);
		
		int size = sizeof(arStr) / sizeof(arStr[0]);
		for (int i = 0; i < size; i++) {
			std::cout << arStr[i] << std::endl;
		}
#endif
///////////////////////////////////////////////////////////////////
#if 0
	//Задание 7. Массивы указателей на функцию.
	//Напишите несколько функций вида
	const char* GetString1();   
	const char* GetString2();
	const char* GetString3();
	const char* GetString4();
	const char* GetString5();

	//		...., каждая из функций возвращает указатель на свою строку
	//(подумайте - какой адрес Вы имеете право возвращать из функции)
	
	// Вам предоставлен код этих функций. 
	//Подумайте:
	//1) все ли они корректны, если нет, то как исправить некорректность
	//2) может быть требуются какие-то дополнительные действия

	//Объявите и проинициализируйте массив указателей на функции
	//GetString1,GetString2...
	//Введите номер функции, которую Вы хотите вызвать:
		int n = 1;

		const char* (*funcPtr[5])() = { GetString1, GetString2, GetString3, GetString4, GetString5 };


	//Вызовите функцию

		const char* result = funcPtr[n]();

	//Распечатайте результат
		std::cout << result;

#endif

////////////////////////////////////////////////////////////////////////////
	//Задание 8*.
	//Создайте одномерный массив (размерность вычисляется в процессе
	//выполнения программы), заполните его значениями.
	//Напишите функцию, которая добавляет в массив новое значение только (!) при условии,
	//что такого значения в массиве еще нет. 
	//Подсказка: при этом размер  массива должен увеличиться!
	//Для проверки напишите функцию, которая выводит значения всех элементов на экран
///////////////////////////////////////////////////////////////////////////
//*********************   Дополнительное задание   ****************************************************
//Задание 9 (*)
// Выполните задание 8 по курсовой работе
// описание задания находится в файле "Задание (игра Змейка)_8 (двумерный динамический массив поля)_3.docx" 
//*****************************************************************************************************


	return 0;
}//main

