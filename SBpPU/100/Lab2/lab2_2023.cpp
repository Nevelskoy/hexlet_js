/*************************************************************
	Практическое занятие №2. 
	
	Инструкции (условная, выбор, циклы)
	Логические операторы, тернарный (условный) оператор 
	Побитовые операторы.
							
*************************************************************/

#include <iostream>

void binary(int x)
{
	for (int i = 31; i >= 0; i--)
	{
		std::cout << ((x >> i) & 1);
	}
	std::cout << std::endl;
}

#define	  stop __asm nop	//с помощью директивы препроцессора задаем макроподстановку
/***************************************************************/
int main()
{
// ********************************************************
	//Задание 1. Условная инструкция if-else.Переключатель switch 

	//Задание 1.1 Напишите фрагмент кода, который переводит код символа, 
	//хранящийся в переменной ch в противоположный регистр.
	//Требуется предусмотреть проверку ситуации, когда пользователь ввел цифру
	//или нажал другую клавишу, которой символ не соответствует

	//Подсказка: работаем только с символами английского алфавита, для которого в таблице
	// кодов ASCII код каждой буквы нижнего регистра на 0x20 больше кода 
	// соответствующей буквы верхнего регистра.
	
	//Обратите внимание, что в кодировочной таблице между буквами верхнего и нижнего регистра 
        //расположены некоторые иные символы
	{
		/*
		// Сформируйте значение переменной ch с помощью потока ввода
		char ch;
		std::cin >> ch;
		bool letter = false;

		if (ch >= 'A' && ch <= 'Z')
			{
				ch += 0x20;
				letter = true;
			}
		else if (ch >= 'a' && ch <= 'z')
			{
				ch -= 0x20;
				letter = true;
			}
		else
			{
				std::cout << "Wrong letter" << std::endl;
			}
		
		std::cout << ch;
			
		//... изменили регистр

		// здесь проверили в отладчике значение или вывели "эхо" на экран
		stop
		*/
	}
	//Задание 1.2 Напишите фрагмент кода, который реализует с помощью if (if/else)
	//следующую логику: 
	//если x меньше или равен 0, y=0
	//если x больше 0 но меньше 1, то y=x,
	//если x больше или равен 1, то y=1
	//Подумайте: какого типа должны или могут быть x и y?
	{
		/*
		short x; // int, short
		std::cin >> x;
		short y;

		if (x <= 0)
		{
			y = 0;
		}
		else if (x < 1)
		{
			y = x;
		} 
		else
		{
			y = 1;
		}
		std::cout << y << std::endl;
		*/
	stop
	}
	//Задание 1.3 Напишите фрагмент кода, который реализует с помощью switch
	//следующую логику: 
	//в переменной cInput типа char дано значение символа,введенного любым способом.
	//Если введен символ 'y' (т.е. yes) в любом регистре, то присвоить
	//переменной у значение переменной x
	//Если введен символ 'n' (т.е. no) в любом регистре, то присвоить
	//переменной у значение (x * 2)
	//Если любой другой симол, то вывести сообщение об ошибке
	{
	/*
		char ch;
		int x = 1;
		int y = 0;
		//сформировали значение
		std::cin >> ch;
		//switch
		switch (ch)
			{
				case 'y':
				case 'Y':
					y = x;
					break;
				case 'n':
				case 'N':
					y = (x * 2);
					break;
				default:
					std::cout << "Error input" << std::endl;
			}
		std::cout << "Y = " << y << std::endl;
	stop
	*/
	}
// ********************************************************
	//Задание 2. Логические операторы.
	// В Григорианском календаре (которым мы все пользуемся) високосный год
	// определяется по следующему алгоритму: високосным является каждый четвертый год,
	// но каждый сотый високосным НЕ является, при этом каждый 400-й год все таки 
	// високосный. Т.е. 1823 - не високосный, 1824 - високосный, 1900 - не високосный,
	// 2000 - високосный.
	// Напишите фрагмент кода, такой что:
	// логическая переменная isLeapYear принимает значение true, если год, заданный
	// переменной year - високосный.

	// Примечание: НЕ надо пользоваться инструкциями if-else, switch и тернарным оператором 
	//             НАДО написать логическое выражение в одну строку.
	//(*)если возникнут затруднения при решении задачи, то можно сначала решить ее с помощью if-else,
	// а потом уже выполнить предложенное задание.
	{
		/*
		int year = 1900;
		//int year = 1824;
		//int year = 1900;
		//int year = 2000;

		//Вычислили значение 
		bool isLeapYear = ((year % 4 == 0) && ((year % 100 != 0) || (year % 400 == 0)));
		std::cout << "isLeapYear = " << isLeapYear << std::endl;
		// проверили значение в отладчике
		stop
		*/
	}


// *******************************************************
	//Задание 3. Тернарный оператор.  
	//С помощью тернарного оператора найдите максимальное из трех значений

	//(*)если возникнут затруднения при решении задачи, то можно сначала решить ее с помощью if-else,
	// а потом уже выполнить предложенное задание.
	{
		/*
		int a1 = 45;
		int a2 = 100;
		int a3 = 232;

		int max = (a1 > a2) ? (a1 > a3 ? a1 : a3) : (a2 > a3 ? a2 : a3);
		std::cout << max << std::endl;

		stop
		*/
	}

// ********************************************************
	//Задание 4. Циклы.

	//Задание 4.1 Напишите фрагмент кода, который реализует с помощью for
	//следующую логику: найти сумму заданного диапазона целых чисел.
	//Задайте границы с помощью потока ввода (или прямо в коде).
	//Предусмотрите защиту от ввода нижней границы больше, чем верхней.
	{

		//1) сформировать границы диапазона

		//2) проверить корректность значений

		//3) вычислить сумму

		//4) проверить в отладчике значение (или вывести на консоль)
	/*
		int first, second;

		do
		{
			std::cout << "Enter correct interval, first > second: " << std::endl;
			std::cin >> first;
			std::cin >> second;
		} while (first > second);

		int accumulate = 0;

		for (int i = first; i <= second; i++)
		{
			accumulate += i;
		}	
		std::cout << accumulate << std::endl;
		stop
	*/
	}


	//Задание 4.2 Напишите фрагмент кода, который реализует с помощью do-while
	//следующую логику: на каждой итерации цикла ввести с консоли целое значение
	// и покинуть цикл, если значение удовлетворяет условию: 
	// значение больше или равно 10 и четное.

	//Замечание: проверка на четность с использованием операции остатка от деления
	//нацело генерирует очень неэффективный код. Попробуйте реализовать альтернативный
	//вариант.
	
	{
	/*
		int num;

		do
		{
			std::cin >> num;
		} while (!(num < 10) || ((num & 1) != 0));

		std::cout << num << std::endl;
	*/

	stop
	}

	//Задание 4.3 Напишите фрагмент кода, который реализует с помощью while
	//следующую логику: исходно int x = 0; 
	//на каждой итерации x=x+1, sum=sum+1/x
	//найти значение x, при котором sum>1.7
	{
		/*
		double sum = 0;
		int x = 0;

		while (sum < 1.7)
		{
			x += 1;
			sum = sum + 1 / static_cast<double>(x);
		}
		std::cout << "X = " << x << std::endl;
		*/
	stop
	}
// ********************************************************
//Задание 5 Побитовая арифметика (and, or, xor, not), сдвиги.
	//5.1 
	{
		
		//а)Задайте значение номера бита с помощью потока ввода. Желательно контролировать корректность ввода
			size_t num_bit;

		//	do
		//	{
		//		std::cout << "Enter a number (0-7): "<< std::endl;
		//		std::cin >> num_bit;
		//	} while (num_bit < 0 || num_bit > 7);

		//	std::cout << num_bit << std::endl;

		////б)  в переменной val обнулите значение бита, заданного переменной num_bit
		//	{
		//		char val1 = 0xff;
		//		std::cout << "1) Change bit in 0: " << std::endl;
		//		binary(val1);

		//		val1 = val1 & ~(1 << num_bit);

		//		binary(val1);
		//		std::cout << "\n" << std::endl;
		//	}
		//stop

		////в)  в переменной val определите значение бита, заданного переменной num_bit
		//	{
		//		char val2 = 0xAA;
		//		int bit = (val2 >> num_bit) & 1;

		//		std::cout << "2) Read bit - " << num_bit << ", bit`s value = " << bit <<std::endl;
		//		binary(val2);
		//		std::cout << "\n" << std::endl;
		//	}

		//stop
		////г)	в переменной val установите  в 1 значение бита, заданного переменной num_bit
		//	{
		//		char val3 = 0;
		//		binary(val3);

		//		val3 = val3 | (1 << num_bit);

		//		std::cout << "3) Change bit in 1: " << std::endl;
		//		binary(val3);
		//		std::cout << "\n" << std::endl;
		//	}
		//stop
		//
		
	}
	//5.2 
	{
	//Если число кодируется более чем одним байтом, то важно, 
	//в каком порядке байты записываются в памяти компьютера или передаются по линиям связи.			//В архитектуре x86  используется порядок от младшего к старшему (англ. little-endian)
	//Для протоколов TCP/IP стандартным является порядок от старшего к младшему (англ. big-endian)  
	//Задайте значение x, например:
	
		//int x = 0xA1B2C3D4;                  //2712847316 
		//unsigned int result = 0;
		//int byte = 0;
		//int bit = 0;
		//int currentBit = 0;

		//for (int i = 0; i < 32; ++i)
		//{
		//	currentBit = (x >> i) & 1;
		//	byte = byte | (currentBit << bit);
		//	bit++;

		//	if (bit == 8)
		//	{
		//		result = result | (byte << (31 - i));
		//		byte = 0;
		//		bit = 0;			
		//		std::cout << std::endl;
		//	}
		//}
		//std::cout << result;
	
	//байты числа в памяти следуют в порядке от младшего к старшему
	//поменяйте местами байты так, чтобы они следовали в памяти в обратном порядке 
	//(от старшего к младшему)
	//Например, если x= 0xA1B2C3D4, то после перестановки получим 0xD4C3B2A1
	
	stop
	}
// ********************************************************
	//Задание 6 Побитовая арифметика (and, or, xor, not), сдвиги.
	//6.1 
	{
		
		int y;//Задайте значение y, например, с помощью потока ввода
		//или с помощью числового литерала в двоичном или 16-ричном виде

		//С помощью побитовых операторов и операторов сдвига:
		//выведите значение "y"  на консоль в двоичном виде, например:
		// если y==9, то
		// 0 0 0 0 ...   0 0 1 0 0 1 (количество двоичных цифр зависит от платформы)

	/*
		int a = 9;
		for (int i = 31; i >= 0; i--)
		{
			std::cout << ((a >> i) & 1);
		}
		std::cout << std::endl;
	*/

	}
	//6.2
	{
			//Выведите значение "y"  на консоль в двоичном виде, 
			//пропустив незначащие нули, например:
			// если y==9, то результат  1 0 0 1
	/*
			int y = 9;
			bool flag = false;

			for (int i = 0; i < 32; i++)
			{
				if (flag == true)
				{
					std::cout << (y >> 31);
				}
				y = y << 1;

				if ((y >> 31) & 1 == 1)
				{
					flag = true;
				}
			}
	*/	
		std::cout << std::hex << 224;
	}
		//6.3 (*)
	{
			//Дана целая переменная
			//Задайте значение y, например, с помощью потока ввода

		//"Сдвиньте" все единицы в этой переменной вправо, например:
		//было:   0100 1111 0000 0000 0110 1111 0000 0010
		//стало:  0000 0000 0000 0000 0000 1111 1111 1111
		//Выведите на консоль полученное значение в двоичном виде ( можно на печати не разделять тетрады пробелом)
		
		int y = 0b001010101001010; //145;
			int bit = 0;
			int result = 0;

			for (int i = 31; i >= 0; i--)
			{
				bit = (y >> i) & 1;
				if (bit)
				{
					result = result | 0x01;
					result = result << 1;
				}
	/*			if (i == 0 && (((result >> 0) & 1) == 0))
				{
					result = result >> 1;
				}*/
			}
			binary(result);
			stop
		
	}
		
		//6.4 (*)
		//Какие операции следует применить к заданному ниже операнду sNum для
		//того, чтобы переменная sRes приняла требуемое значение?

		//Замечание 1: значения подобраны таким образом, что в каждом случае достаточно
		//использовать один оператор (и при необходимости маску) 

		//Замечание 2: посредством оператора xor (подобрав соответствующую маску)
		//можно получить любое значение => этот оператор предполагается использовать
		//в том случае, когда все остальные уже "не сасают" 
		{
				short sNum = 0x8008;
				short sRes;

				//0x7ff7 // sRes = ~sNum;

				//0x8ff8 // sRes = sNum | 0x0ff0;

				//0x0008 // sRes = sNum & 0x0f;

				//0x7f08 // sRes = sNum ^ 0xff00;

				//0xf001 // sRes = sNum ^ 0x7009;

				//0x0010 // sRes = sNum ^ 0x8018;

				stop
		}
			//*********************   Дополнительное задание   ****************************************************
			//Задание 7 (*)  
			// Выполните задание 1 по курсовой работе 
			// описание задания находится в файле "Задание (игра Змейка)_1 (клавиатурный ввод)_3.docx"
			// Каждое задание выполняется в отдельном проекте
			// Рекомендация:
			// Все проекты (project), связанные с курсовой работой имеет смысл помещать в одно решение (solution)
			//*****************************************************************************************************
			return 0;//код завершения приложения
}	// Конец функции main()
	
