/*************************************************************
	Практическое занятие №3-курс-С110. Структуры
//динамический массив структур
//поиск
//сортировка
//сохранение в файле
//чтение из файла
*************************************************************/
#include <iostream>
#include <conio.h>
#include "book.h"
#include "card_index.h"


#define	  stop __asm nop	

//BOOK globalBook;
//BOOK book1 = { "Global", "Book", 2017, 19.99, HISTORY };


void main()
{
#if 0

	//Тема. Структуры С.	
//Задание 1.1 Объявите структуру BOOK, описывающую книгу
//(автор, заглавие, год издания, цена, категория…).
//Подумайте: какого типа могут быть поля структуры.
//Подсказка: объявление структуры рекомендуется выносить
//в заголовочный файл.

	//Задание 1.2. Создайте разными способами экземпляры (объекты) типа BOOK 

	//a) глобальный объект типа BOOK создайте без инициализации
	
	//б) динамический объект типа BOOK создайте также без инициализации
	BOOK* dynamicBook = new BOOK;
	//в) локальный объект типа BOOK создайте без инициализации, но позднее заполните вручную поля структуры некоторыми значениями
	BOOK localBook;	
	strcpy_s(localBook.author, "Bjarne Stroustrup");
	strcpy_s(localBook.title, "The C++ Programming Language");
	localBook.category = PROGRAMMING;
	localBook.year = 1986;
	localBook.price = 10.55;

	//г) статический объект типа BOOK создайте  и проинициализируйте при определении с помощью списка инициализации.
	// 
	//static BOOK staticBook = { "Robert Martin", "Clean Architecture", 2017, 19.99, "Programming" };

	//Используйте структуру BOOK, созданную в предыдущем задании.
	//Для этого достаточно переписать и подключить к проекту файлы book.h и book.cpp
	//Определите - сколько памяти отводит компилятор под каждый такой объект. 
	//Подумайте: от чего зависит объем выделяемой памяти?
	// 
	// 
// (50+50+4+8+4), итоговый размер занимаемой памяти зависит от компилятора и архитектруры 
	
	/*Задание 1.3.1 Напишите функцию, выводящую на экран реквизиты книги. 
	Прототип функции поместите в файл "book.h", а реализацию - в "book.cpp"
	Подумайте: как эффективнее передавать экземпляр BOOK в функцию.
	Для вывода на консоль используйте функцию стандартной библиотеки printf*/
	std::cout << "Global BOOK" << std::endl;
	printInfo(&book1);
	std::cout << std::endl;
	//Задание 1.3.2
	//С помощью разработанной функции выведите на консоль информацию о книгах, созданных в п.1.2 (кроме динамической)
	std::cout << "Local BOOK" << std::endl;
	printInfo(&localBook);
	std::cout << std::endl;
	//Задание 1.4.1 Напишите функцию для формирования полей структуры.
	//Прототип функции поместите в файл "book.h", а реализацию - в "book.cpp"
	//Для ввода используйте функцию стандартной библиотеки scanf

	//Замечание: неплохо заложить в такую функцию возможность проверки
	//корректности введенного значения, например, год издания не может быть
	//меньше, чем... (год появления письменности), категорию пользователь
	//должен выбирать из существующих, цена не может быть отрицательной...
	inputBook(&globalBook);
	//Задание 1.4.2
	//Используйте разработанную функцию для заполнения полей динамически созданного экземпляра книги 
	//распечатайте содержимое этой книги с помощью функции, соданной в п.1.3.1 
	//
	std::cout << "NEW BOOK" << std::endl;
	printInfo(&globalBook);
	std::cout << std::endl;

#endif
//----------------------------------------------------------------------------------------------------------------
	//Задание 2.1 Создаем "картотеку".
	
	//Пользователь должен иметь возможность по своему желанию выполнять
	//разные действия с картотекой => нужно такую возможность ему
	//предоставить: это может выглядеть как вывод "меню" (перечень
	//возможных действий и соответствующих реакций пользователя), например:
	//Распечатать содержимое картотеки (1)
	//Ввести новую книгу (2)
	//Удалить существующую(ие) (3)
	//...
	//Выход из программы (...)

	//"Картотека" - это массив структур => нужно такой массив создать.
	//Замечание: размер массива придется увеличиватьпо мере добавления книг => Каким должен быть такой массив???	

	//Помимо самого массива потребуется хранить дополнительно текущие значения количества книг и емкости этого массива,
	//так как эти значения могут изменяться в процессе работы
	//Поскольку эти параметры логически связаны, имеет смысл объединить их в структуру, например, CARD_INDEX
	// ПОДРОБНЫЕ ПОДСКАЗКИ к работе над картотекой описаны в файле  "Картотека_2021.pdf"

	//Реализуйте посредством функций разные возможности работы с картотекой
	
	// Упрощения:
	//1. пусть автор и заглавие книги состоят из одного слова
	//2. все строки можно задавать латинскими буквами. 
	//   для вывода русских символов требуется установить кодировку  -	setlocale(LC_CTYPE, ".1251");
	//   (заголовочный файл <clocale>)
	//   Если хочется не только выводить, но и вводить русские символы, следует
	//   а) пользоваться расширенными функциями ввода/вывода - wprintf(), wscanf()
	//   б) хранить строки как расширенные - wchar_t
	//   в) установить кодировку для ввода русских символов - setlocale(LC_CTYPE, ".866");

	int count = 0;
	int capacity = 5;
	
	CARD_INDEX* newCatalog = new CARD_INDEX;
	newCatalog->pB = new BOOK * [capacity];
	newCatalog->count = 0;
	newCatalog->capacity = capacity;

	int cmd;
	do {
		system("cls");
		switch (cmd = menu()) {
		case 1:
			printCatalog(newCatalog);
 			break;
		case 2:
			addBook(newCatalog);
			break;
		case 3:
			exportCatalog(newCatalog);
			break;
		case 4:
			importCatalog(newCatalog);
			break;
		case 5:
			deleteBook(newCatalog);
			break;
		case 0:
			break;
		default:
			printf("Invalid input. Let's try again!\n");
			_getch();
		}

	} while (cmd);

	printf("Connect closed\n");
	clearCARD(newCatalog);



//----------------------------------------------------------------------------------------------------------------
	//Задание 2.2 (*) Дорабатываем "картотеку".	

	//Записать текущее содержимое картотеки в файл (4)
	//Считать из файла содержимое в картотеку (5)

	//Подсказка1:	для файлового ввода/вывода используйте функции fprintf и fscanf
	//				(заголовочный файл <cstdio>


	// Подсказка2: удобно в качестве первого данного в файле хранить количество
	//			   книг в картотеке

	// Подсказка3:  для чтения из файла можно использовать следующий алгоритм:
	//				Если файл существует и его удалось открыть:
	//if()
	//{
	//Чтение данных из файла
	//а) считали количество элементов
	//б) создали массив требуемой размерности
	//в) считали данные из файла в массив
	//}

	//----------------------------------------------------------------------------------------------------------------
	//Задание 3 (*). Предоставьте пользователю возможность выводить перечень книг
	//в определенном порядке => напишите функцию (функции) сортировки массива
	//по любому из полей структуры.
	// НЕ (!!!) используйте функцию sort  из 2-ой лабораторной работы, а напишите 
	//функцию  сортировки сами  (либо  selection, либо пузырьковую)

	//Замечание: признак - "по какому полю сортируем" можно ввести с помощью
	//перечисления.


//При завершении программы пребуется очистить динамическую память. Не забудьте это сделать
//*********************   Дополнительное задание   ****************************************************
//Задание 4 (*)  
// Выполните задание 9 по курсовой работе 
// описание задания находится в файле "Задание (игра Змейка)_9 (структуры)_3.docx" 
//*****************************************************************************************************
}
