/*************************************************************
	Практическое занятие 1. Встроенные многомерные массивы.
							Динамическое выделение памяти.
							Простейшие алгоритмы сортировки и поиска.
							Сложные указатели.
							Ссылки.
*************************************************************/
#include <iostream>
#include <string.h>
#include <iomanip>
#include "Lab1_C110_2023.h"


#define	  stop __asm nop



int main()
{

	///////////////////////////////////////////////////////////////
	//			Встроенные  многомерные массивы                               //
	///////////////////////////////////////////////////////////////
#if 0
	//Задание 1.
	//а)Объявите трехмерный N*M*K массив и сформируйте указанные
	//значения элементов следующим образом:
	//(проинициализируйте массив при определении)
	//						  |------------|
	//  					/ |	5  5  5  5 |
	//					   |------------|5 |
	//  				 / | 4  4  4  4 |5 |
	//				    |------------|4 |__|
	//			      / | 3  3  3  3 |4 |/
	//    			 |------------|3 |__|
	//			   / | 2  2  2  2 |3 | /
	//			  |------------|2 |__|
	//			  | 1  1  1  1 |2 | /
	//			  | 1  1  1  1 |__|
	//			  | 1  1  1  1 | /
	//			  |____________|
		{
		const int N = 5;
		const int M = 3;
		const int K = 4;
		int arr5_1[N][M][K] = {
			{
				{1, 1, 1, 1},
				{1, 1, 1, 1},
				{1, 1, 1, 1}
			},
			{
				{2, 2, 2, 2},
				{2, 2, 2, 2},
				{2, 2, 2, 2}
			},
			{
				{3, 3, 3, 3},
				{3, 3, 3, 3},
				{3, 3, 3, 3}
			},
			{
				{4, 4, 4, 4},
				{4, 4, 4, 4},
				{4, 4, 4, 4}
			},
			{
				{5, 5, 5, 5},
				{5, 5, 5, 5},
				{5, 5, 5, 5}
			}
		};
	stop
	}

	//б) объявите трехмерный N*M*K неинициализированный массив, 
	// присвойте значения элементам с помощью кода
	//						  |------------|
	//  					/ |	5  5  5  5 |
	//					   |------------|5 |
	//  				 / | 4  4  4  4 |5 |
	//				    |------------|4 |__|
	//			      / | 3  3  3  3 |4 |/
	//    			 |------------|3 |__|
	//			   / | 2  2  2  2 |3 | /
	//			  |------------|2 |__|
	//			  | 1  1  1  1 |2 | /
	//			  | 1  1  1  1 |__|
	//			  | 1  1  1  1 | /
	//			  |____________|
		
		const int N = 5;
		const int M = 3;
		const int K = 4;
		int arr5_2[N][M][K];

		for (int i = 0; i < N; i++) {
			for (int y = 0; y < M; y++) {
				for (int z = 0; z < K; z++) {
					arr5_2[i][y][z] = i + 1;
				}
			}
		}

	//Рекомендация: В качестве размерностей массива лучше указать N, M, K,
	//а не задавать их жестко.

	//Средствами отладчика проверьте правильность Вашего решения.

	//Или выведите содержимое массива на печать.
		for (int i = 0; i < N; i++) {
			for (int y = 0; y < M; y++) {
				for (int z = 0; z < K; z++) {
					std::cout << arr5_2[i][y][z];
				}
				std::cout << std::endl;
			}
			std::cout << std::endl;
		}

	// Удобно выводить построчно каждый слой  массива и
	//после каждого слоя пропускать строку для того, чтобы отделить один слой от другого

	//в) найдите сумму элементов массива, объявленного в пункте б) 
	//Подумайте, как это сделать эффективно.
		int accumulate = 0;
		int size_arr5_2 = sizeof(arr5_2) / sizeof(int);
		int* ptr = arr5_2[0][0];

		for (int i = 0; i < size_arr5_2; i++) {
			accumulate += *(ptr + i);
		}
		std::cout << "sum of elements = " << accumulate << std::endl;
		std::cout << std::endl;
	//г) объявите трехмерный N*M*K  массив и проинициализируйте его при определении:
	//				     |--------|
	//			       / |3  0  0 |
	//      		 |---------|0 |
	//    		   / | 2  0  0 |0 |
	//			  |---------|0 |__|
	//			  | 1  0  0 |0 | /
	//			  | 0  0  0 |__|
	//			  | 0  0  0 | /
	//			  |_________|
		{
			const int A = 3;
			const int B = 3;
			const int C = 3;
			int arr3_1[A][B][C] = { {{1}},{{2}},{{3}} };
			//вывод массива на печать

			for (int i = 0; i < A; i++) {
				for (int y = 0; y < B; y++) {
					for (int z = 0; z < C; z++) {
						std::cout << arr3_1[i][y][z];
					}
					std::cout << std::endl;
				}
				std::cout << std::endl;
			}
		}

	//д) Инициализация массивов строковыми литералами:
	//Объявите и проинициализируйте строковыми литералами два массива:
	//двумерный массив символов и одномерный массив указателей на char. 
	//Поясните разницу в использовании элементов таких массивов.
#endif

#if 0
		{
			char first[][10] = { "Happy", "New", "Year" };

			const char* second[] = { "Happy", "New", "Year" };     // 1) Содержит только адрес каждого строкового литерала, 
																   // 2) Невозможна модификация через обращение по адресу
			first[1][1] = 'W';
		//	second[1][2] = 'W';

			first[1][0] = 'F';
			std::cout << first[1];
		//	std::cout << second[1];
		

		}
#endif		
	
	/////////////////////////////////////////////////////////////////////
	//Задание 2.
	//С помощью данной заготовки напишите программу,которая:
	//вводит строки с клавиатуры с помощью cin>>...
	//в объявленный Вами двухмерный ВСТРОЕННЫЙ массив 10*80 элементов типа char;
	//признаком конца ввода является символ * (то есть строка - "*") или
	//заполнение всего массива (больше свободных строк нет);

	//То есть:
		//a) можно заполнять весь массив полностью (не забудьте подсказать, сколько элементов в массиве)
		//б) можно заполнять массив частично, до тех пор, пока пользователь не ввел строку "*".
		//Например:вводим строки (строки с пробелами не задаются, т.к. пробелы являются разделителями):
		//"Hello"
		//"Ok"
		//"*"
	//Выполните сортировку строк в алфавитном порядке. 
	// 
	//Пояснение: крайне не рекомендуется для сортировки сложных объектов физически
	//перемещать их в памяти ( в нашем случае перемещать (копировать) строки)
	//Намного эффективнее завести массив указателей на соответствующие строки 
	//и перемещать только указатели на начало строк (массивов символов).
	//Вопрос: При таком способе что будет  отсортировано?

	//Подсказка: для лексикографического сравнения строк пользуйтесь
	//функцией стандартной библиотеки strcmp(...), заголовочный файл <string.h>.
	
	//int strcmp(char const* _Str1, char const* _Str2);

	// далее Вам предлагается алгоритм, следуя которому, Вы сможете решить задачу.
	
#if 0
		{
		//Определите необходимые значения как константы
		//STOP_STRING  -  "*"	//признак "прекратить ввод"
		//M  -  80	//максимальный размер одной строки
		//N  -  10	//максимальное количество строк в массиве
			const int M = 80;
			const int N = 10;
			const char* STOP_STRING = "*";
		//Объявите двухмерный массив с именем cBuffer типа char и
		// размерностью N*M
			char cBuffer[N][M] = {{""}};
		//Объявите массив (с именем cPointers) указателей на строки
		//размерностью N
			char* cPointers[N];
		//Цикл ввода строк:
		//а) выведите приглашение для ввода
			std::cout << "Enter 10 words. To finish, write \"*\" " << std::endl;
		//б) пока не введена строка STOP_STRING или не заполнен весь массив
		//ввод строки в массив cBuffer:
		//если введена строка - признак окончания, то выйти из цикла
			int count_words = 0;
			while (count_words < N) {
				std::cout << "Enter word " << count_words + 1 << ":" << std::endl;
				std::cin >> cBuffer[count_words];
				if (!strcmp(cBuffer[count_words],STOP_STRING)) {
					break;
				}
				count_words++;
			}
		//Присвойте элементу массива cPointers с индексом nIndex
		//указатель на строку с номером nIndex в массиве cBuffer
			for (int i = 0; i < count_words; i++) {
				cPointers[i] = cBuffer[i];
			}
		//Выдать диагностику о том, что прием строк завершен.
			std::cout << std::endl;
			std::cout << "Ok, your strings: " << std::endl;
		//Распечатайте содержимое массива
			for (int i = 0; i < count_words; i++) {
				for (int z = 0; z < M; z++) {
					std::cout << cBuffer[i][z];
				}
				std::cout << std::endl;
			}
			std::cout << std::endl;
		//Теперь сортируем строки:
			for (int i = 0; i < count_words; i++) {
				for (int j = 0; j < count_words - i - 1; j++) {
				//	if (strcmp(cPointers[j], cPointers[j + 1]) > 0) {
					if (cPointers[j][0] > cPointers[j + 1][0]) {
						char* tmp = cPointers[j];
						cPointers[j] = cPointers[j + 1];
						cPointers[j + 1] = tmp;
					}	
				}
			}
	//Цикл сортировки строк по методу "всплывающего пузырька" в
	//порядке возрастания кода первого символа

	//Распечатайте содержимое массива после сортировки
			std::cout << "SORTED: " << std::endl;
			for (int i = 0; i < count_words; i++) {
				for (int z = 0; z < M; z++) {
					std::cout << cPointers[i][z];
				}
				std::cout << std::endl;
			}
	}
#endif
	//////////////////////////////////////////////////////////////////////////////
#if 0
	//Задание 3*. Объявление и использование указателей на многомерные
	// массивы. Проинициализируйте трехмерный массив 
	//так, как показано на рисунке и напишите фрагмент
	//кода, который меняет местами значения элементов четных
	//и нечетных слоев:
	//	было:
	//					    |-----------|
	//  				  / |4  4  4  4 |
	//				     |-----------|4 |
	//			       / |3  3  3  3 |4 |
	//    			 |------------|3 |__|
	//			   / | 2  2  2  2 |3 | /
	//			  |------------|2 |__|
	//			  | 1  1  1  1 |2 | /
	//			  | 1  1  1  1 |__|
	//			  | 1  1  1  1 | /
	//			  |____________|

	//	стало:	

	//					   |------------|
	//  				  /| 3  3  3  3 |
	//				     |-----------|3 |
	//			       / |4  4  4  4 |3 |
	//    			 |------------|4 |__|
	//			   / | 1  1  1  1 |4 | /
	//			  |------------|1 |__|
	//			  | 2  2  2  2 |1 | /
	//			  | 2  2  2  2 |__|
	//			  | 2  2  2  2 | /
	//			  |____________|
	const size_t N = 4, M = 3, K = 4;
	double dArray[N][M][K];

	for (int i = 0; i < N; i++) {
		for (int y = 0; y < M; y++) {
			for (int z = 0; z < K; z++) {
				dArray[i][y][z] = i + 1;
			}
		}
	}
	std::cout << "ARRAY:" << '\n' << '\n';
	for (int i = 0; i < N; i++) {
		for (int y = 0; y < M; y++) {
			for (int z = 0; z < K; z++) {
				std::cout << dArray[i][y][z];
			}
			std::cout << std::endl;
		}
		std::cout << std::endl;
	}

	//Замечание: НЕ НУЖНО МОДИФИЦИРОВАТЬ ВЫРАЖЕНИЯ СПРАВА ОТ ЗНАКА РАВЕНСТВА!!!
	//... =  dArray[i];
	//... =  dArray[i+1];
	//Подсказки:
	//1) Слева от знака равенства надо определить два  сложных указателя.
	//Так как справа находятся "имена" слоев, т.е. двумерных массивов, то
	// остается вспомнить какой указатель является эквивалентным для имени двумерного массива.
	//2)дальше, воспользовавшись этими указателями, переставляем местами элементы i-того и i+1-ого слоев
	
	double (*ptr_1)[K] = dArray[0];
	double (*ptr_2)[K] = dArray[0];

	for (size_t i = 0; i < N - 1; i += 2) {
		ptr_1 = dArray[i];
		ptr_2 = dArray[i + 1];
		for (size_t j = 0; j < sizeof dArray[0] / sizeof(double); j++) {
			double tmp = *(*ptr_1+j);
			*(*ptr_1 + j) = *(*ptr_2 + j);
			*(*ptr_2 + j) = tmp;
		}
	}

	std::cout << "RESULT:" << '\n' << '\n';

	for (int i = 0; i < N; i++) {
		for (int y = 0; y < M; y++) {
			for (int z = 0; z < K; z++) {
				std::cout << dArray[i][y][z];
			}
			std::cout << std::endl;
		}
		std::cout << std::endl;
	}
#endif
	///////////////////////////////////////////////////////////////////////////
#if 0
	//Задание 4
	//а) Объявите двухмерный ВСТРОЕННЫЙ массив элементов типа char.
	//Сформируйте значения элементов массива с помощью генератора случайных
	//чисел таким образом, чтобы в массиве были только символы '_' и '*'

		//Подсказка 1: для генерации случайных чисел используйте функцию
		//стандартной библиотеки - rand() (<cstdlib>)
		//Можно с помощью генератора случайных чисел  и оператора % получать значения 0 и 1,
		// а в массив помещать соответственно '_' и '*'.


		//Подсказка 2: На самом деле те значения, которые создаются генератором случайных
		//чисел являются "псевдослучайными", то есть при двух последовательных запусках
		//приложения Вы получаете две одинаковые последовательности значений.
		//Для того чтобы генерируемые "случайные" значения были разными при каждом
		//запуске приложения используйте функции стандартной библиотеки srand() (<cstdlib>)
		//и time() (<ctime>).
		//Функция srand() осуществляет "привязку" начала генерации к указанному в качестве параметра значению.
		//Функция time() задает эту точку отсчета, считывая текущее время
		//srand( time( 0 ) );

		//Замечание: в программе запускать функцию srand()  достаточно один раз


	//В каждой строке "сдвиньте звездочки" в начало строки, например:
	//было - '*' '_' '_' '*' '*' '_' '*' '_' '*' '_'
	//стало: '*' '*' '*' '*' '*' '_' '_' '_' '_' '_'
	//и распечатайте массив по строкам - "постройте распределение"
	const size_t N = 6, M = 10;
	char arr[N][M];
	char one = '*';
	char empty = '_';
	srand(time(0));

	for (int i = 0; i < N; i++) {
		for (int j = 0; j < M; j++) {
			arr[i][j] = (rand() % 2 == 0) ? one : empty;
		}
	}

	std::cout << "The array is generated:" << std::endl;
	for (int i = 0; i < N; i++) {
		for (int j = 0; j < M; j++) {
			std::cout << arr[i][j];
		}
		std::cout << std::endl;
	}

/*
	for (int i = 0; i < N; i++) {
		int counter = 0;
		for (int j = 0; j < M; j++) {
			if (arr[i][j] == one) {
				arr[i][j] = '_';
				arr[i][counter] = one;
				counter++;
			}
		}
	}

*/	
	// б) Модифицируйте предыдущее задание следующим способом:
	//После заполнения массива с помощью генератора случайных чисел
	//"сдвиньте" звездочки по столбцам вниз и распечатайте полученное
	//"распределение"

	for (int i = 0; i < M; i++) {
		int counter = N - 1;
		for (int j = N - 1; j > 0 - 1; j--) {
			if (arr[j][i] == one) {
				arr[j][i] = '_';
				arr[counter][i] = one;
				counter--;
			}
		}
	}


	std::cout << std::endl;
	std::cout << "The array shifted:" << std::endl;
	for (int i = 0; i < N; i++) {
		for (int j = 0; j < M; j++) {
			std::cout << arr[i][j];
		}
		std::cout << std::endl;
	}

#endif

	///////////////////////////////////////////////////////////////
	//			Динамическое выделение памяти                    //
	///////////////////////////////////////////////////////////////
	//Задание 5.
#if 0
		////Задание 5а.Создайте ДИНАМИЧЕСКИЙ двухмерный массив с размерностями,
		//вычисляемыми в процессе выполнения программы - N*M.
		//Задайте значения элементов помощью генератора случайных чисел.
	{
		size_t N = 5;
		size_t M = 7;

		int* pArr = new int[N * M];
		srand(time(0));
		for (size_t i = 0; i < N * M; i++) {
			*(pArr + i) = rand() % 10;
		}
		std::cout << "The array is generated:" << std::endl;
		for (size_t i = 0; i < N; i++) {
			for (size_t j = 0; j < M; j++) {
				std::cout << pArr[i * M + j];
			}
			std::cout << std::endl;
		}
		std::cout << std::endl;
		//Задание 5б. В сформированном массиве отсортируйте каждую строку по
		//убыванию значений. Используйте сортировку "выбором"

		int** ppArr = new int* [N];
		for (int i = 0; i < N; i++) {
			ppArr[i] = pArr + i * M;
		}

		for (size_t i = 0; i < N; i++) {
			for (size_t j = 0; j < M - 1; j++) {
				int max = j;
				for (size_t jn = j + 1; jn < M; jn++) {
					if (ppArr[i][max] < ppArr[i][jn]) {
						max = jn;
					}
				}
				int temp = ppArr[i][max];
				ppArr[i][max] = ppArr[i][j];
				ppArr[i][j] = temp;
			}
		}

		std::cout << "The array is sorted:" << std::endl;
		for (size_t i = 0; i < N; i++) {
			for (size_t j = 0; j < M; j++) {
				std::cout << pArr[i * M + j];
			}
			std::cout << std::endl;
		}
		std::cout << std::endl;

		//Задание 5в. Объявите одномерный массив размерностью N.
		//Сформируйте значение i-ого элемента одномерного массива  
		//равным среднему значению элементов i-ой строки
		//двухмерного массива

		double* arr_2 = new double[N];

		for (int i = 0; i < N; i++) {
			double sum = 0;
			for (int j = 0; j < M; j++) {
				sum += *(ppArr[i] + j);
			}
			arr_2[i] = static_cast<double>(sum) / M;
		}

		std::cout << "The average number:" << std::endl;
		for (size_t i = 0; i < N; i++) {
			std::cout << std::fixed << std::setprecision(1) << *(arr_2 + i) << " | ";
		}

		std::cout << std::endl;
		//Подсказка - не забудьте освободить память!
		delete[] ppArr;
		delete[] pArr;
		delete[] arr_2;
		ppArr = nullptr;
		pArr = nullptr;
		arr_2 = nullptr;
	}
#endif
	/////////////////////////////////////////////////////////////////////////////
#if 1
	{
		//Задание 6. 
			//Реализуйте задание 2, используя не встроенные, а ДИНАМИЧЕСКИЕ массивы (массив?).
			// Важно! 
			//Так как строки могут быть разной длины, /эффективным решением было бы 
			//отводить под каждую строку ровно столько байтов, сколько требуется для ее хранения.
			//
			//Для того, чтобы определить длину введенной строки можно воспользоваться 
			//функцией strlen 
			//size_t strlen(char const* _Str);

			//При этом значение количества строк сформируйте с помощью потока ввода
		const char* STOP_STRING = "*";
		int nStringNumber;
		
		std::cout << "Write the number of words:" << std::endl;
		std::cin >> nStringNumber;
		int length_word = 0;
	
		char** DataWords = new char* [nStringNumber];
		//Цикл ввода строк:
		int count_words = 0;
		for (int i = 0; i < nStringNumber; i++) {
			char buffer[20];
			std::cout << "Enter word " << count_words + 1 << ":" << std::endl;
			std::cin >> buffer;
			if (!strcmp(buffer, STOP_STRING)) {
				break;
			}
			int length_word = strlen(buffer);
			DataWords[i] = new char[length_word + 1];  // выделение памяти для строки
			strcpy_s(DataWords[i], length_word + 1, buffer);
			count_words++;

		}
		nStringNumber = count_words;
		// Для ввода строки нужно использовать буфер "достаточного" размера. 
		// В качестве такого буфера обычно используется встроенный массив.
		// Для того, чтобы введенную строку  скопировать из буфера в массив  строк,
		// можно воспользоваться функцией strcpy
		//char* strcpy(	char* _Dest,  char const* _Source);
		//  или
		// 
		//errno_t strcpy_s(char* _Dest, size_t  _SizeInBytes, char const* _Source); 
		//где _SizeInBytes - размер "приемного" буфера _Dest

		//Замечание: 
		//скорее всего,если Вы используете strcpy, то при компиляции Вы получите следующую ошибку:
		//Severity	Code	Description	Project	File	Line	Suppression State
		//	Error	C4996	'strcpy': This function or variable may be unsafe.
		//Consider using strcpy_s instead.To disable deprecation, use _CRT_SECURE_NO_WARNINGS.

		//Это происходит потому, что функция strcpy считается небезопасной.

		//Для того, чтобы пользоваться функцией strcpy, а не strcpy_s, можно
		//  - либо объявить макрос #define _CRT_SECURE_NO_WARNINGS   (обязательно ДО всех #include !!!!!)
		//- либо установить режим без доп. проверки на безопасность Properties->C/C++ ->General->SDL checs -> No
		
		//ТЕСТ
		//abc
		//aBc3
		//ASDF
		//23
		//123456
		//a1
		//1###

		//Цикл сортировки строк по методу "всплывающего пузырька" в
		//порядке возрастания кода первого символа

		for (int i = 0; i < nStringNumber - 1; i++) {
			for (int j = 0; j < nStringNumber - i - 1; j++) {
				if (DataWords[j][0] > DataWords[j + 1][0]) {
					char* temp = DataWords[j];
					DataWords[j] = DataWords[j + 1];
					DataWords[j + 1] = temp;
				}
			}
		}

		std::cout << "SORTED: " << std::endl;
		for (int i = 0; i < count_words; i++) {		
			std::cout << DataWords[i] << std::endl;
		}

		//Освобождение занятой памяти:
		for (size_t i = 0; i < nStringNumber; i++)
		{
			delete[] DataWords[i];
		}
		delete[] DataWords;
		DataWords = nullptr;

	}
#endif
//*********************   Дополнительное задание   ****************************************************
//Задание 7 (*)  
// Выполните задание 7 по курсовой работе 
// описание задания находится в файле "Задание (игра Змейка)_7 (двумерный встроенный массив поля)_3.docx" и 
//*****************************************************************************************************


	//size_t N = 5;
	//size_t M = 7;

	//int* pArr = new int[N * M];

	//for (size_t i = 0; i < N * M; i++) {
	//	*(pArr + i) = rand() % 10;
	//}
	//std::cout << "The array is generated:" << std::endl;
	//for (size_t i = 0; i < N; i++) {
	//	for (size_t j = 0; j < M; j++) {
	//		std::cout << pArr[i * M + j];
	//	}
	//	std::cout << std::endl;
	//}
	//int a = 5;
	//delete[] pArr;

	return 0;
}

