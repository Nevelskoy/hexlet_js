/*************************************************************
	Практическое занятие №3. Директивы препроцессора.
							Указатели.
*************************************************************/

#include "stdafx.h"
#define _USE_MATH_DEFINES
#include <math.h>

#define	  stop __asm nop	//с помощью директивы препроцессора задаем
							//макроподстановку

int _tmain()
{
// ********************************************************
	//Задание 1. Директивы препроцессора

	//1.1. Использование "математических" макросов стандартной библиотеки:
	//в заголовочном файле <cmath> (который в свою очередь включает старый
	//файл math.h) определены часто используемые математические
	//константы, например M_PI. Воспользуйтесь этой константой для
	//вычисления длины окружности.
	//Обратите внимание: определения констант в свою очередь тоже заключены
	//в директивы условной трансляции. Что еще, кроме подключения заголовочного
	//файла, требуется сделать???
// *******************************************************

	//int radius = 3;
	//int lenghtCircle = 2 * M_PI * radius;
	//std::cout << lenghtCircle;
	
	//1.2.Макросы с параметрами.
	//1.2.1 Напишите свою макроподстановку LENGHT которая вычисляет длину окружности.
	// протестируйте написанный макрос для следующих ситуаций:
	
	//#define	 LENGHT(x) (2 * M_PI * (x))

	//{
	//	float l1 = LENGHT(1 + 2); // должно быть 18.8495...
	//	std::cout << l1 << std::endl;
	//	float l2 = 1 / LENGHT(2); // должно быть 0.07957...
	//	std::cout << l2 << std::endl;
	//	stop
	//}
// *******************************************************

	//1.2.2 (B) определите макрос MAX(A, B)  для вычисления б'ольшего
	//значения из двух.
	
	//Используйте макрос следующим образом. Следите за изменением
	//значений переменных k, i, j. Объясните результат.
	//Постарайтесь убрать побочные эффекты.
	//Отметьте случаи, когда избежать побочных эффектов невозможно
	
	//#define MAX(A, B) (A > B ? A : B)

	//int i = 10, j = 12, k;
	//k = MAX(i, j); 			//  i= 10  j= 12  k=12
	//k = MAX(j, i) * 2;		//  i= 10  j= 12  k=24
	//k = MAX(j, i+3);		    //  i= 10  j= 12  k=13 
	//k = MAX(i--, j++);		//  i= 9   j= 14  k=13 // побочный эффект неизбежен, постфиксная операция выполняется после каждой подстановке переменной

// *******************************************************

	//1.2.3 определите макрос EXCHANGE(X, Y)  для перестановки
	//двух объектов типа int в памяти местами. Проверьте для приведенного
	//фрагмента. Подумайте, что будет делать макроподстановка, если
	//переставляемые значения разного типа???
	
	//#define EXCHANGE(X, Y) { \
	//int Z = X; \
	//X = Y; \
	//Y = Z; \
	//}

	//int x1=1, y1=-1;
	//EXCHANGE(x1,y1);
	//std::cout << "x1 = " << x1 << " y1 = " << y1 << std::endl;
	//
	//int x2=100, y2=-100;
	//EXCHANGE(x2,y2);
	//std::cout << "x2 = " << x2 << " y2 = " << y2 << std::endl;


// *******************************************************


	//1.3. Директивы условной трансляции
	//Выполняя следующий фрагмент, посмотрите, какое
	//значение принимает переменная iNN. Что нужно сделать
	//для того, чтобы результат был равен 0? 1? 2?

//#define NNN
//#define MMM  // Комбинируем макроопределение 
//
//int iNN;
//#if defined NNN && defined MMM
//	iNN = 0;
//#elif defined MMM
//	iNN = 1;
//#elif defined NNN 
//	iNN = 2;
//
//#else
//	iNN = -1;
//#endif
//std::cout << "iNN = " << iNN << std::endl;
//	stop

	
// *******************************************************

	//Задание 1.4. Загляните в Project -> Properties -> диалоговая панель
	//- Property Pages -> C\C++  -> Preprocessor -> Preprocessor definitions.
	//В опциях командной строки в зависимости от мишени сборки проекта
	//(Debug или Release) может быть определено с помощью ключа /D
	//имя _DEBUG. С помощью директив условной
	//трансляции напишите фрагмент кода, который в зависимости от типа
	//мишени выводит с помощью cout разный текст на консоль. Проверьте
	//при разных мишенях сборки.

	//Пусть
	//для мишени Debug в процессе выполнения данного участка
	//кода на экран выводится информация об
	//имени файла, номере строки с функцией вывода, дате и времени 
	//компиляции файла, содержащего данную функцию вывода,
	//а также имя функции, содержащей данную строку.

	//Для мишени Release должна быть просто выведена строка
	//"Release configuration!"

	//Подсказка: для получения нужной информации зайдите в online справку
	//(Help -> View Help), выберете язык C++ и в поле поиска введите 
	//следующую ключевую фразу: Predefined Macros
	// Или пройдите по ссылке: https://docs.microsoft.com/en-us/cpp/preprocessor/predefined-macros?view=msvc-160
//
//#if defined _DEBUG
//
//std::cout << "Filename: " __FILE__ << std::endl;
//std::cout << "String Nr: " << __LINE__ << std::endl;
//std::cout << "LastCompileTime: " __DATE__ << ", " << __TIME__ << std::endl;
//std::cout << "FunctionName: " __FUNCTION__ << std::endl;
//
//#else
//std::cout << "Release configuration!";
//#endif

// *******************************************************
	{
	//Задание 1.5  Управляя определенностью идентификатора _UNICODE и используя
		//возможности заголовочного <tchar.h>, определим и проинициализируем переменную,
		//которая может становиться как однобайтовой, так и расширенной без 
		//изменения исходного текста.
		//С помощью отладчика проверьте результат (определите значение в 10-чной и 16-чной системе счисления).

	//Подсказка: Для того, чтобы настроить проект на работу с  некоторой кодировкой, надо:
		//1)Выбрать Project -> Properties. Будет открыта диалоговая панель  Property Pages  
		//2)Configuration Properties -> Advansed-> Advansed Properties -> Character Set
		//3) установить флаг "Use Unicode Character Set", если требуется Unicode
		//4) установить флаг "Not Set", если требуется  работа с однобайтовыми символами.
		// 
//Замечание:  В следующие 4 строки не надо вносить никаких изменений, только добавить комментарии 
// В комментариях указать значения кодов символов в 10-чной и 16-чной системе счисления
		TCHAR ch1 = __T('A');	// ch1=65, 0x0041 | 0x41, 65
		size_t s1 = sizeof(ch1);// s1=2, 0x00000002 | 0x00000001, 1
		TCHAR ch2 = __T('Ф');	// ch2=1060, 0x0424 | 0xd4, -44
		TCHAR ch3 = 'Ф';	// ch3=65492, 0xffd4 | 0xd4, -44
	}
	// *******************************************************
	{
		//Задание 1.6
		//Создайте файл предкомпиляции.
		//Особого смысла в этой простой лаб. работе это не имеет.
		// Задание предлагается для знакомства с техникой создания файла предкомпиляции

        //В случае нашей лабораторной работы можно поместить директивы препроцессора, 
		//подключающие библиотечные файлы в отдельный заголовочный файл и создать файл предкомпиляции.
		//По умолчанию при создании нового проекта в Visual Studio в проекте указывается имя stdafx.h(VS 2019) 
		// в качестве имени файла предкомпилированного заголовка. Имя этого файла может быть изменено, но с целью упрощения мы этого делать не будем.
		//Надо выполнить несколько шагов :
		//1) Создать файл stdafx.h и поместить в него заголовки библиотечных файлов, которые будут использованы в работе
        //2) Создать файл реализации stdafx.cpp  и в него поместить единственную строку   #include "stdafx.h" 
		//3) В клиентском файле с исходным кодом подключить заголовочный файл stdafx.h
		//4) Задать ключи для файлов реализации :
		//		для stdafx.cpp - / Yc
		//		для lab3.cpp - / Yu		
	}
// ********************************************************
	//Задание 2.Заголовочные файлы. Директива #include
	//Создайте и подключите к проекту два заголовочных файла 1.h и 2.h
	//В каждом заголовочном файле объявите перечисление с одинаковыми именами
	//констант, но сопоставьте именованным константам разные значения, например:
	//1.h - enum MyEnum{My1, My2, My3};  . 2.h - enum MyEnum{My1=5, My2, My3};
	//С помощью директив условной трансляции в DEBUG-версии пользуйтесь значениями
	//констант из 1.h, а в RELEASE-версии значениями констант из 2.h

//#if defined _DEBUG
//#include "1.h"
//#else
//#include "2.h"	
//#endif
//		MyEnum numeric;
//		numeric = My3;
//		numeric == 2 ? std::cout << "debug" : std::cout << "release, " << My3;

// ********************************************************

	//Задание 3. Указатели
	//Объявите  несколько объектов разных типов и проинициализируйте их.
	//Объявите указатели соответствующих типов и проинициализируйте их
	//адресами заданных объектов. 
	//Выполняя задание, с помощью отладчика посмотрите, какие значения
	//будут присвоены переменным-указателям и на что эти указатели
	//"указывают"

	//int one = 42;
	//double two = 21.0;
	//unsigned char three = 255;
	//											 // при каждой инициализации будут новые адреса
	//int* first = &one;							 // 0x0079f7e0 {42}	int *   
	//double* second = &two;						 // 0x0079f7d0 {21.000000000000000}	double *
	//unsigned char* third = &three;				 // 0x00effc9b "яММММММММ"	unsigned char *

// *******************************************************

	//Задание 4. Арифметика указателей. Операция разыменования указателя.
	//Выполняя задание, следите за изменением значений
	//указателей и значений объектов, на которые они указывают.
	//Интерпретируте наблюдаемые результаты
	{
		int nAr[3] = {1,3};
		int* pn = &nAr[0];  // pn содержит адрес элемента с индексом 0 массива nAr. 
		(*pn)++;            // после разыменования указателя pn происходит постфиксное увеличение значение элемента с индексом 0 массива nAr. Массив {2,3,0}	
		pn++;				// указатель перемещается на следующий объект в массиве (элемент с индексом 1 {3})

		char cAr[]={'A','B','C','D'};
		char* pc = &cAr[0];
		(*pc)=(*pc)+5;	             // увеличиваем значение первого элемента на 5, теперь cAr = {'F','B','C','D'}
		pc=pc+3;					 // pc	0x00c1f92f "DММММММММHщБ"	char *, указатель на элемент D

		double dAr[3]={1.0,2.0};			
		double* pd1 = &dAr[0];			
		double* pd2 = pd1;			// вложенный указатель на первый элемент массива dAr
		(*pd2)+=2;					// *pd2	3.0000000000000000	double, изменение массива {3.0, 2.0, 0.0}
		pd2+=2;						// pd2 = 0, переместились на два объекта в памяти

		//Объясните результат выполнения операции
		//вычитания двух указателей
		pd1 = &dAr[0];			//=3.0
		pd2 = &dAr[1];			//=2.0
		int nNumber=pd2 - pd1;  //=1    результат вычитания говорит о том, на сколько элементов один адрес отстоит от другого
		
		//Сравните указатели pd2 и pd1 и с помощью cout
		//выведите результаты сравнения.

		//if (pd2 > pd1) {
		//	std::cout << "pd2>pd1";
		//}
		//else if (pd2 == pd1) {
		//	std::cout << "pd2 == pd1";
		//}
		//else {
		//	std::cout << "pd2 < pd1";
		//}
		//stop
	}

// *******************************************************
/*
	//Задание 5. Void-указатель. 
	//5.1. Выполняя задание, посмотрите - какие значения присваиваются
	//void-указателю. Обратите внимание: средствами отладчика Вы
	//не можете посмотреть значения, на которые "указывает"
	//void-указатель
	void*	pVoid;	//объявление void-указателя
	int	nObject3=5;
	char cObject3='A';
	int*	pInt = &nObject3;	//pInt	0x003cf6c4 {0x00000005}	int *
	pVoid=&nObject3;			//pVoid	0x003cf6bb	void *
	pVoid=&cObject3;			// указатель типа void может указывать на объект любого типа
	pVoid=pInt;					// компилятор не знает, на какой тип данных указывает указатель void, поэтому он не может автоматически преобразовать его значение в конкретный тип.
	
	//Прежде, чем раскомментировать следующую строчку, вспомните:
	//что нужно сделать, чтобы выражение стало корректным 	
	pInt=static_cast<int*>(pVoid);
	
// *******************************************************

	//5.2. При выполнении следующего фрагмента посмотрите, какие неприятности
	//могут Вас ожидать при явном приведении типа void-указателя,
	//который в момент времени (1) указывает на double, к типу 
	//указателя на int (2) 

	double dObject3 = 33.33;
	pVoid = &dObject3;	//(1) 		pVoid	0x00b6fcc0	void *
	int nTmp = *(static_cast<int*>(pVoid) ); //(2)   = nTmp	1889785610	int  //  размеры и представления данных различны для double и int.
	stop
*/
// *******************************************************

/*
	//Задание 6.При выполнении задания обратите внимание на то,
	//как наглядно отладчик "раскрывает" конструкции типа
	//"указатель на указатель" и на способы получения конечного
	//объекта по таким "иерархическим" указателям
	int	n1=1;

    //Объявите указатель pn и проинициализируйте его так, чтобы он
	//"указывал" на n1
	int* pn = &n1;

    //Объявите указатель ppn и проинициализируйте его так, чтобы он
	//"указывал" на pn
	int** ppn = &pn;

    //Объявите указатель pppn и проинициализируйте его так, чтобы он
	//"указывал" на ppn
	int*** pppn = &ppn;
  
	//С помощью указателей pn, ppn и ppn получите значение объекта n1
	//и присвойте его n2

	//int n2 = *pn;
	//int n3 = **ppn;
	//int n4 = ***pppn;
*/
	stop

//*********************   Дополнительное задание   ****************************************************
//Задание 7 (*)  
// Выполните задание 2 по курсовой работе 
// описание задания находится в файле "Задание (игра Змейка)_2 (змейка на экране)_3.docx"
// Каждое задание выполняется в отдельном проекте
// Рекомендация:
// Все проекты (project), связанные с курсовой работой имеет смысл помещать в одно решение (solution)
//*****************************************************************************************************


	return 0;
}//end main
