#include <iostream>
#include "myRect.h"
#include "myString.h"
#include "Bochka.h"


#define stop __asm nop

int main()
{
using namespace std;
#if 0
	//Задание 1.Объявление класса. Создание экземпляра класса.
	//Вызов методов класса. 
	//Откройте закладку Class View - (здесь Вы увидите имена методов и
	//данных - классов Rect и MyString)
	//Обратите внимание на пиктограммы слева от имен членов класса - они
	//обозначают спецификатор доступа к каждому члену класса.

	//Какой конструктор вызывается при создании экземпляра класса?
	{
		Rect rect;  // конструктор по умолчанию
		stop
	}

	//1a. Объявите и определите конструктор с параметрами для
	//инициализации переменных класса. Создайте экземляры класса Rect
	//с помощью конструктора с параметрами. Если компилятор выдает
	//ошибку в предыдущем фрагменте, подумайте - чего ему не
	//хватает? Добейтесь отсутствия ошибок.
	//Выполняя задание с самого начала по шагам, определите:
	//в какой момент происходит вызов конструктора(какого?)?

	//Замечание*: хорошо было бы учесть тот факт, что прямоугольник
	//может оказаться "ненормализованным", то есть m_left>m_right или/и
	//m_top>m_bottom
	//Подсказка: учтите, что пользователь Вашего класса может указывать
	//в качестве параметров любые значения! Например:
	
	Rect rrr(4,3,2,1); // на схеме Фигуры: стр 1 - почему top < bottom??? 
	

	stop
		//1б. При конструировании объекта посредством конструктора без параметров
		//предусмотрите инициализацию переменных класса, например, нулем

	Rect rect2;
	
	stop
		//1в. Объявите, определите и вызовите метод класса InflateRect(), 
		//который увеличивает размеры прямоугольника на заданные приращения
		//(раздвигая стороны от центра - каждую сторону на свое значение).
		//Подсказка: объявить и определить методы можно не только "вручную",
		//но и с помощью Wizard-a Class View. Для этого: откройте закладку
		//ClassView окна проекта, сделайте активным класс Rect и нажмите
		//правую кнопку мыши - в появившемся контекстном меню выберите
		//Add/Add Member Function... С помощью появившейся диалоговой панели
		//"дайте указания" Wizard-у как объявить и определить метод.

	rrr.InflateRect(-2, 2, 3, 2);
	stop
#endif

	//Задание 2.Перегрузка конструкторов и методов класса.
	//Конструктор копирования.
#if 0
	//2а.Объявите и определите конструктор копирования в классе Rect.
	//Выполняя задание по шагам, определите, какой
	//конструктор вызывается при создании r1,r2,r3 и r4?
	//Чему равны переменные созданных объектов?
		Rect r1;				// конструктор по умолчанию
		Rect r2(1,2,3,4);		// конструктор с параметрами
		Rect r3 = r1;			// конструктор копирования
		Rect r4(r2);			// конструктор копирования
		stop


  //2б. Объявите и определите в классе Rect метод InflateRect(),
	//который принимает два аргумента, по умолчанию равных 1, и 
	//раздвигает стороны прямоугольника на на заданные приращения.
	//Для каких объектов вызывается функция InflateRect()?
		r1.InflateRect(1,1);		// InflateRect(unsigned int x, unsigned int y)
		r2.InflateRect(2,2);		// InflateRect(unsigned int x, unsigned int y)
	////Какая из функций InflateRect() вызывается в каждом из трех случаев?
		r3.InflateRect(2,2,2,2);	// InflateRect(int dl, int dr, int dt, int db)
		r3.InflateRect(3,3);		// InflateRect(unsigned int x, unsigned int y)
		r3.InflateRect(5);			// InflateRect(unsigned int x, unsigned int y)	
		r3.InflateRect();			// InflateRect(unsigned int x, unsigned int y)
	stop

	//Задание 3.Спецификаторы доступа. Инкапсуляция. 
	{
	Rect r;
	//Раскомментируйте следующую строку. Объясните ошибку
	//компилятора

//	int tmp = r.m_left;   //private по умолчанию


	//Введите в класс Rect метод void SetAll(...),
	//который присваивают переменным класса передаваемые
	//значения. Вызовите созданный метод, проверьте корректность. 

	r.SetAll(3, 5, 3, 1);


	//Введите в класс Rect парный метод GetAll(...),
	//который "достает" значения private-переменных класса.
	//Вызовите созданный метод, проверьте корректность. 
	int x1, x2, y1, y2;
	r.GetAll(x1, x2, y1, y2);
	cout << "m_left = " << x1 << " m_right = " << x2 << " m_top = " << y1 << " m_bottom = " << y2 << endl;

	stop
	}
#endif

#if 0
	//Задание 4.Передача экземпляра класса в качестве параметра
	//функции. Возвращение объекта класса по значению. Поставив
	//остановы в конструкторе копирования или выполняя фрагмент
	//по шагам, определите: в какой момент происходит обращение
	//к конструктору копирования. 
	//Создайте глобальную функцию 
	// Rect BoundingRect(Rect, Rect);
	//которая принимает два объекта класса Rect по значению и
	//возвращает объект класса Rect, который является прямоугольником,
	//в который вписаны заданные прямоугольники. Как происходит
	//передача параметров и возвращение объекта класса?

	{

		Rect r1(1,2,4,3), r2(5,6,8,7), r3;
	//	r3= BoundingRect(r1, r2);				// 1. Параметры передаются с помощью пользовательского конструктора копирования 
												// 2. Также обращение к конструктору копирования происходит при возвращении экземпляра класса
	//stop
	
	//Задание 4а. Передача объектов по ссылке.
	//Создайте глобальную функцию BoundingRect2, которая выполняет ту же
	//задачу, принимая параметры по ссылке
	//Вызываются ли конструкторы при передаче параметров?
	

	//	r3 = BoundingRect2(r1, r2);				// 1. Обращение к конструктору копирования происходит при возвращении экземпляра класса
	//stop


		//Задание 4б.Реализуйте ту же задачу (BoundingRect) методом класса

		r3.BoundingRect3(r1, r2);

		//int x1, x2, y1, y2;
		//r3.GetAll(x1, x2, y1, y2);
		//cout << "m_left = " << x1 << " m_right = " << x2 << " m_top = " << y1 << " m_bottom = " << y2 << endl;
	}

#endif

#if 0
	//Задание 5. Когда вызываются конструкторы и деструкторы.
	//Объявите и определите
	//явный деструктор класса. Поставьте остановы в 
	//конструкторе (конструкторах) и деструкторе. Определите: когда для
	//каждого из объектов вызывается конструктор, а когда - деструктор?
	{
		Rect r1;										//пользовательский конструктор класса
		Rect*	pR = new Rect(1,2,1,2);					//пользовательский конструктор класса
		{
			Rect r2(r1);								//конструктор копирования
			Rect arRect[2];								//пользовательский конструктор класса
			for(int i=0; i<3; i++)
			{
				static Rect r3 (i,i,i,i) ;
				Rect r4(*pR);
				Rect r5(i,i,i,i);
			}											// 6 раз вызов деструктора класса
		}												// 3 раза вызов деструктора класса (массив из 2х элементов + скопированный класс)
		delete pR;										// 1 деструктора класса для pR
		stop
	}													// 1 деструктора класса для r1
#endif


#if 0
	//Задание 6.Конструктор + деструктор = функциональное
	// замыкание. Класс MyString
	// Посредством конструктора (конструкторов) и деструктора обеспечьте
	//корректные инициализацию и деактивацию объекта
	//C помощью остановов определите когда происходит
	//захват и освобождение памяти для строки-члена класса
	{
		MyString	str1("It's my string1!");
		//Создайте метод GetString(), который обеспечит доступ к хранящейся строке.
		//С помощью cout и метода GetString() распечатайте строку объекта str1
		//Замечание: подумайте, как следует корректно реализовать метод GetString().

		//Подсказка 1:
		////приведенный ниже код должен работать:
		std::cout<<str1.GetString()<<std::endl;

		////Подсказка 2:
		////приведенный ниже код НЕ должен работать:
		//str1.GetString()[1] = 'W';

		////Подсказка 3:
		////приведенный ниже код должен работать:
		const MyString	str2("It's my string2!");
		std::cout<<str2.GetString()<<std::endl;
	}
	stop

#endif

#if 0
	//6a. Раскомментируйте следующий фрагмент. Подумайте - какие
	//неприятности Вас ожидают. Попробуйте исправить положение (как?)
		{
			MyString str1("The first string!");
			MyString str2 = str1;
			std::cout << str2.GetString() << std::endl;
			// Необходимо обеспечить существование всех данных объекта независимо,
			// реализуем пользовательский конструктор копирования.
		}
		stop

	//6б. Реализуйте метод SetNewString, который будет заменять строку
	// на новую

		MyString str1("Base string!");
		std::cout << str1.GetString() << std::endl;
		str1.SetNewString("Changed string!");
		std::cout << str1.GetString() << std::endl;

#endif

#if 1
	//Задание 7.  Решите с помощью классов следующую задачу:
	//даны две бочки известного объема. В одной бочке в начальный момент
	//времени содержится спирт (96%), в другой – вода.
	//Кружкой емкостью 1л переливаем итеративно содержимое из одной бочки
	//в другую следующим способом: на каждой итерации
	//зачерпнули из первой бочки -> вылили во вторую
	// 
	//зачерпнули из второй бочки -> вылили в первую.
	//Требуется определить номер итерации, на которой концентрация спирта в
	//первой бочке станет меньше 50%.

	//Bochka spirt(...);
	//Bochka water(...);
	//...
	//	while(концентрация спирта в бочке spirt > 50%)
	//	{
	//		spirt.Pereliv(water); //или spirt.Pereliv(water, объем_кружки);
	//		water.Pereliv(spirt); // аналогично
	//		...

	//	} 159

		Bochka spirt(100, 0.96);
		Bochka water(100, 0);

		double cup = 1.0;
		int iteration = 0;

		while (spirt.GetAlco() > 0.5) {
			spirt.Pereliv(water, cup);
			water.Pereliv(spirt, cup);
			iteration++;
		}
		cout << "less than 50 % after " << iteration << " iterations." << endl;

#endif

return 0;

}//end_main

